#!/usr/bin/env python3
"""
–ê–≥–µ–Ω—Ç –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è v0.2
–£–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å —É–º–Ω—ã–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–π –∏ –ª—É—á—à–∏–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º
"""

import os
import requests
import json
import time
import subprocess
import tempfile
import shutil
from datetime import datetime
from github import Github, GithubException
from jenkins import Jenkins, JenkinsException
import logging
import sys
from llama_cpp import Llama

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class GGUFModelClient:
    def __init__(self, model_path: str):
        self.model_path = model_path
        self.llm = None

    def load_model(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ GGUF –º–æ–¥–µ–ª–∏"""
        try:
            if not os.path.exists(self.model_path):
                logger.error(f"Model file not found: {self.model_path}")
                return False

            logger.info("ü§ñ Loading GGUF model...")
            self.llm = Llama(
                model_path=self.model_path,
                n_threads=os.cpu_count(),
                n_ctx=8192,
                n_batch=512,
                top_k=40,
                top_p=0.9,
                repeat_penalty=1.1,
                verbose=False,
                echo=False,
                stop=["</s>"]
            )
            logger.info("‚úÖ GGUF model successfully loaded!")
            return True

        except Exception as e:
            logger.error(f"‚ùå Failed to load model: {e}")
            return False

    def generate_text(self, prompt: str, max_tokens: int = 8000,
                     temperature: float = 0.7) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–∞ —Å –ø–æ–º–æ—â—å—é –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏"""
        if not self.llm:
            logger.error("Model not loaded")
            return ""

        try:
            full_prompt = f"""[INST] <<SYS>>
–¢—ã - —ç–∫—Å–ø–µ—Ä—Ç –ø–æ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ Java + Selenium.
–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π –ø–æ–ª–Ω–æ—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π Java —Ç–µ—Å—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ–ø–∏—Å–∞–Ω–∏—è —Å—Ü–µ–Ω–∞—Ä–∏—è.
–ò—Å–ø–æ–ª—å–∑—É–π Java 11+, Selenium 4+, JUnit 5, WebDriverWait.
–í–µ—Ä–Ω–∏ —Ç–æ–ª—å–∫–æ Java –∫–æ–¥ –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –æ–±—ä—è—Å–Ω–µ–Ω–∏–π.
<</SYS>>

{prompt}

–í–µ—Ä–Ω–∏ —Ç–æ–ª—å–∫–æ Java –∫–æ–¥. [/INST]"""

            output = self.llm(
                full_prompt,
                max_tokens=max_tokens,
                temperature=temperature
            )

            result_text = output["choices"][0]["text"].strip()
            return self._clean_generated_code(result_text)

        except Exception as e:
            logger.error(f"Text generation error: {e}")
            return ""

    def _clean_generated_code(self, code: str) -> str:
        """–û—á–∏—Å—Ç–∫–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–æ–¥–∞"""
        if not code:
            return ""

        lines = code.split('\n')
        cleaned_lines = []

        for line in lines:
            if any(artifact in line for artifact in ['[INST]', '<<SYS>>', '[/INST]', '<s>', '</s>']):
                continue
            if line.strip() in ['```java', '```']:
                continue
            cleaned_lines.append(line)

        return '\n'.join(cleaned_lines).strip()


class TestAutomationAgent:
    def __init__(self, github_token: str, jenkins_url: str,
                 jenkins_username: str, jenkins_token: str,
                 model_path: str, github_username: str,
                 scenario_repo: str, aft_repo: str):
        self.github_token = github_token
        self.github_username = github_username
        self.jenkins_url = jenkins_url
        self.jenkins_username = jenkins_username
        self.jenkins_token = jenkins_token

        # –†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏ (–ø–æ–ª–Ω—ã–µ –∏–º–µ–Ω–∞ —Å username)
        self.scenario_repo_name = scenario_repo  # format: "username/scenario"
        self.aft_repo_name = aft_repo  # format: "username/AFT"

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥–µ–ª–∏
        self.model_client = GGUFModelClient(model_path)

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–æ–≤
        try:
            self.github_client = Github(github_token)
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
            user = self.github_client.get_user()
            logger.info(f"üîó Connected to GitHub as: {user.login}")
        except Exception as e:
            logger.error(f"‚ùå GitHub connection failed: {e}")
            raise

        self.jenkins_client = None
        try:
            self.jenkins_client = Jenkins(
                jenkins_url,
                username=jenkins_username,
                password=jenkins_token,
                timeout=30
            )
            # –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
            self.jenkins_client.get_version()
            logger.info(f"üîó Connected to Jenkins version: {self.jenkins_client.get_version()}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Jenkins connection failed: {e}")
            logger.warning("Jenkins operations will be skipped")
            self.jenkins_client = None

        # –î–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π
        self.last_checked = datetime.now()
        self.processed_files = set()
        
        # –°–ª–æ–≤–∞—Ä—å –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π —Ñ–∞–π–ª–æ–≤ (filename -> {sha, last_modified})
        self.file_tracking = {}

        # –ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏
        if not self.model_client.load_model():
            logger.warning("‚ö†Ô∏è Failed to load model, using fallback mode")

    def _is_file_changed(self, filename, current_sha, current_modified):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∏–∑–º–µ–Ω–∏–ª—Å—è –ª–∏ —Ñ–∞–π–ª"""
        if filename not in self.file_tracking:
            # –ù–æ–≤—ã–π —Ñ–∞–π–ª - –≤—Å–µ–≥–¥–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º
            self.file_tracking[filename] = {
                'sha': current_sha,
                'last_modified': current_modified
            }
            logger.info(f"üÜï New file detected: {filename}")
            return True
        
        tracked_info = self.file_tracking[filename]
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º SHA (—Å–∞–º—ã–π –Ω–∞–¥–µ–∂–Ω—ã–π —Å–ø–æ—Å–æ–±)
        if tracked_info['sha'] != current_sha:
            # –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ
            self.file_tracking[filename] = {
                'sha': current_sha,
                'last_modified': current_modified
            }
            logger.info(f"üîÑ File modified: {filename}")
            return True
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–∞—Ç—É –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏ (–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞)
        if tracked_info['last_modified'] != current_modified:
            # –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ
            self.file_tracking[filename] = {
                'sha': current_sha,
                'last_modified': current_modified
            }
            logger.info(f"üîÑ File modified (by date): {filename}")
            return True
        
        return False

    def scan_scenario_repository(self):
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤ –Ω–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è"""
        try:
            logger.info(f"üîç Scanning repository: {self.scenario_repo_name}")
            repo = self.github_client.get_repo(self.scenario_repo_name)

            # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ñ–∞–π–ª—ã –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏
            contents = repo.get_contents("")
            changed_files = []

            for content in contents:
                if content.type == "file" and content.name.endswith('.txt'):
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏–∑–º–µ–Ω–∏–ª—Å—è –ª–∏ —Ñ–∞–π–ª
                    if self._is_file_changed(content.name, content.sha, content.last_modified):
                        changed_files.append(content.name)
                        logger.info(f"üìù File changed: {content.name}")
                elif content.type == "dir":
                    # –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
                    sub_contents = repo.get_contents(content.path)
                    for sub_content in sub_contents:
                        if sub_content.type == "file" and sub_content.name.endswith('.txt'):
                            if self._is_file_changed(sub_content.path, sub_content.sha, sub_content.last_modified):
                                changed_files.append(sub_content.path)
                                logger.info(f"üìù File changed: {sub_content.path}")

            logger.info(f"üìä Found {len(changed_files)} changed files: {changed_files}")
            return set(changed_files)

        except GithubException as e:
            logger.error(f"‚ùå Error scanning repository {self.scenario_repo_name}: {e}")
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
            try:
                self.github_client.get_repo(self.scenario_repo_name)
            except GithubException as e:
                if e.status == 404:
                    logger.error(f"Repository {self.scenario_repo_name} not found!")
                    logger.error("Please check:")
                    logger.error("1. Repository exists")
                    logger.error("2. You have access to it")
                    logger.error("3. Format is 'username/repository-name'")
                else:
                    logger.error(f"GitHub error: {e}")
            return set()

    def download_scenario_file(self, filename):
        """–°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ —Å—Ü–µ–Ω–∞—Ä–∏—è"""
        try:
            logger.info(f"‚¨áÔ∏è Downloading scenario file: {filename}")
            repo = self.github_client.get_repo(self.scenario_repo_name)
            file_content = repo.get_contents(filename).decoded_content.decode('utf-8')

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –∫–æ–ø–∏—é
            temp_dir = tempfile.mkdtemp()
            file_path = os.path.join(temp_dir, filename)

            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(file_content)

            logger.info(f"‚úÖ File downloaded successfully: {filename}")
            return file_path, file_content

        except GithubException as e:
            logger.error(f"‚ùå Error downloading file {filename}: {e}")
            return None, None

    def generate_java_test_code(self, scenario_content, filename):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è Java –∫–æ–¥–∞ —Ç–µ—Å—Ç–∞ —Å –ø–æ–º–æ—â—å—é GGUF –º–æ–¥–µ–ª–∏"""
        test_name = os.path.splitext(os.path.basename(filename))[0].replace(' ', '_').replace('-', '_')
        logger.info(f"ü§ñ Generating Java test code for: {test_name}")
        
        prompt = f"""–û–ø–∏—Å–∞–Ω–∏–µ —Å—Ü–µ–Ω–∞—Ä–∏—è:
{scenario_content}

–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è:
- –ò–º—è –∫–ª–∞—Å—Å–∞: {test_name}Test
- –ò—Å–ø–æ–ª—å–∑—É–π JUnit 5
- –î–æ–±–∞–≤—å WebDriverWait –¥–ª—è –æ–∂–∏–¥–∞–Ω–∏–π
- –í–∫–ª—é—á–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —à–∞–≥–æ–≤
- –î–æ–±–∞–≤—å cleanup –≤ @After –º–µ—Ç–æ–¥"""

        java_code = self.model_client.generate_text(prompt)

        if java_code and self.validate_java_code(java_code):
            logger.info(f"‚úÖ Generated valid code for {test_name}Test")
        else:
            logger.warning("‚ö†Ô∏è Model unavailable or generated invalid code, using fallback")
            java_code = self._generate_fallback_test(test_name, scenario_content)

        return java_code, f"{test_name}Test.java"

    def _generate_fallback_test(self, test_name, scenario_content):
        """–†–µ–∑–µ—Ä–≤–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ—Å—Ç–∞ –µ—Å–ª–∏ –º–æ–¥–µ–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞"""
        logger.info(f"üîÑ Generating fallback test for: {test_name}")
        return f"""package tests;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.support.ui.WebDriverWait;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import java.time.Duration;

public class {test_name}Test {{
    private WebDriver driver;
    private WebDriverWait wait;

    @BeforeEach
    public void setUp() {{
        System.setProperty("webdriver.chrome.driver", "/path/to/chromedriver");
        driver = new ChromeDriver();
        wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        driver.manage().window().maximize();
    }}

    @Test
    public void test{test_name}() {{
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ—Å—Ç
        // –°—Ü–µ–Ω–∞—Ä–∏–π: {scenario_content}

        // TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —à–∞–≥–∏ —Å—Ü–µ–Ω–∞—Ä–∏—è
    }}

    @AfterEach
    public void tearDown() {{
        if (driver != null) {{
            driver.quit();
        }}
    }}
}}
"""

    def validate_java_code(self, java_code):
        """–í–∞–ª–∏–¥–∞—Ü–∏—è —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ Java –∫–æ–¥–∞"""
        if not java_code:
            return False

        required_patterns = [
            "class", "WebDriver", "@Test",
            "import org.junit", "import org.openqa.selenium"
        ]

        return all(pattern in java_code for pattern in required_patterns)

    def push_to_aft_repository(self, java_code, java_filename):
        """–ó–∞–≥—Ä—É–∑–∫–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–æ–¥–∞ –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π AFT"""
        try:
            if not self.validate_java_code(java_code):
                logger.warning(f"‚ö†Ô∏è Generated code failed validation: {java_filename}")
                return False

            logger.info(f"üì§ Pushing to AFT repository: {java_filename}")
            aft_repo = self.github_client.get_repo(self.aft_repo_name)
            file_path = f"src/test/java/tests/{java_filename}"

            # –°–æ–∑–¥–∞–µ–º –±–æ–ª–µ–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–æ–º–º–∏—Ç–∞
            commit_message = f"Auto-update test: {java_filename}\n\nGenerated from scenario update at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"

            try:
                existing_file = aft_repo.get_contents(file_path)
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –ª–∏ –∫–æ–¥ –∏–∑–º–µ–Ω–∏–ª—Å—è
                if existing_file.decoded_content.decode('utf-8') == java_code:
                    logger.info(f"‚ÑπÔ∏è File {file_path} unchanged, skipping update")
                    return True
                
                aft_repo.update_file(file_path, commit_message, java_code, existing_file.sha)
                logger.info(f"‚úÖ Updated file: {file_path}")
                logger.info(f"üìù Commit: {commit_message}")
                
            except GithubException as e:
                if e.status == 404:
                    # –§–∞–π–ª –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π
                    aft_repo.create_file(file_path, commit_message, java_code)
                    logger.info(f"‚úÖ Created new file: {file_path}")
                    logger.info(f"üìù Commit: {commit_message}")
                else:
                    raise e

            return True

        except GithubException as e:
            logger.error(f"‚ùå Error pushing to AFT repository: {e}")
            if e.status == 404:
                logger.error(f"Repository {self.aft_repo_name} not found!")
                logger.error("Please check:")
                logger.error("1. Repository exists")
                logger.error("2. You have access to it")
                logger.error("3. Format is 'username/repository-name'")
            return False

    def run(self, scan_interval=300):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —Ä–∞–±–æ—Ç—ã –∞–≥–µ–Ω—Ç–∞"""
        logger.info("üöÄ Starting Test Automation Agent v0.2")
        logger.info(f"üìÇ Monitoring: {self.scenario_repo_name}")
        logger.info(f"üìÇ Target: {self.aft_repo_name}")
        logger.info(f"‚è∞ Scan interval: {scan_interval} seconds")

        try:
            while True:
                try:
                    changed_files = self.scan_scenario_repository()

                    if changed_files:
                        logger.info(f"üîÑ Processing {len(changed_files)} changed files: {changed_files}")

                        for filename in changed_files:
                            logger.info(f"üìù Processing file: {filename}")
                            success = self.process_scenario(filename)
                            if success:
                                self.processed_files.add(filename)
                                logger.info(f"‚úÖ Successfully processed: {filename}")
                            else:
                                logger.error(f"‚ùå Failed to process: {filename}")
                    else:
                        logger.info("‚ÑπÔ∏è No changes detected")

                    logger.info(f"‚è≥ Waiting {scan_interval} seconds until next scan...")
                    time.sleep(scan_interval)

                except Exception as e:
                    logger.error(f"‚ùå Error in main loop: {e}")
                    time.sleep(scan_interval)

        except KeyboardInterrupt:
            logger.info("üõë Agent stopped by user")

    def process_scenario(self, filename):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–Ω–æ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è"""
        logger.info(f"üîÑ Processing scenario: {filename}")

        file_path, scenario_content = self.download_scenario_file(filename)
        if not scenario_content:
            return False

        java_code, java_filename = self.generate_java_test_code(scenario_content, filename)

        if not self.push_to_aft_repository(java_code, java_filename):
            return False

        # –û—á–∏—â–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
        if file_path and os.path.exists(os.path.dirname(file_path)):
            shutil.rmtree(os.path.dirname(file_path))
            logger.info(f"üßπ Cleaned up temporary files for: {filename}")

        logger.info(f"‚úÖ Scenario {filename} processed successfully")
        return True


# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
if __name__ == "__main__":
    # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è - –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è!
    import os
    from dotenv import load_dotenv

    load_dotenv()

    GITHUB_TOKEN = os.getenv('GITHUB_TOKEN', 'your_github_token_here')
    GITHUB_USERNAME = os.getenv('GITHUB_USERNAME', 'johny19844')
    JENKINS_URL = os.getenv('JENKINS_URL', 'http://localhost:8080')
    JENKINS_USERNAME = os.getenv('JENKINS_USERNAME', 'admin')
    JENKINS_TOKEN = os.getenv('JENKINS_TOKEN', 'your_jenkins_token')
    MODEL_PATH = os.getenv('MODEL_PATH', './models/yandex-gpt.gguf')

    # –ò–º–µ–Ω–∞ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤ –≤ —Ñ–æ—Ä–º–∞—Ç–µ username/repository
    SCENARIO_REPO = os.getenv('SCENARIO_REPO', 'johny19844/scenario')
    AFT_REPO = os.getenv('AFT_REPO', 'johny19844/AFT')

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
    if GITHUB_TOKEN == 'your_github_token_here':
        logger.error("‚ùå Please set GITHUB_TOKEN environment variable!")
        logger.error("Create a .env file with your GitHub token")
        exit(1)

    try:
        agent = TestAutomationAgent(
            github_token=GITHUB_TOKEN,
            jenkins_url=JENKINS_URL,
            jenkins_username=JENKINS_USERNAME,
            jenkins_token=JENKINS_TOKEN,
            model_path=MODEL_PATH,
            github_username=GITHUB_USERNAME,
            scenario_repo=SCENARIO_REPO,
            aft_repo=AFT_REPO
        )

        agent.run(scan_interval=300)

    except Exception as e:
        logger.error(f"‚ùå Failed to initialize agent: {e}")
        logger.error("Please check your configuration:")
        logger.error("1. GitHub token and repository names")
        logger.error("2. Jenkins URL and credentials")
        logger.error("3. Model file path")
